<meta charset="utf-8" emacsmode="-*- markdown -*-">
<!-- link rel="stylesheet" href="https://casual-effects.com/markdeep/latest/apidoc.css?" -->
<!-- from: https://autodesk.github.io/standard-surface/style/style.css -->
<style>
/******************************************************************************/
/* Fonts
/******************************************************************************/

@font-face {
  font-family: 'Artifakt Legend';
  font-style: normal;
  font-weight: 700;
  src: url('https://autodesk.github.io/standard-surface/style/fonts/Artifakt/Artifakt Legend Bold.woff2') format('woff2');
}

@font-face {
  font-family: 'Artifakt Element';
  font-style: normal;
  font-weight: 400;
  src: url('https://autodesk.github.io/standard-surface/style/fonts/Artifakt/Artifakt Element Regular.woff2') format('woff2');
}

@font-face {
  font-family: 'Artifakt Element';
  font-style: normal;
  font-weight: 500;
  src: url('https://autodesk.github.io/standard-surface/style/fonts/Artifakt/Artifakt Element Medium.woff2') format('woff2');
}

@font-face {
  font-family: 'Artifakt Element';
  font-style: normal;
  font-weight: 700;
  src: url('https://autodesk.github.io/standard-surface/style/fonts/Artifakt/Artifakt Element Bold.woff2') format('woff2');
}

@font-face {
  font-family: 'Roboto Mono';
  font-style: normal;
  font-weight: 400;
  src: local('Roboto Mono'), local('RobotoMono-Regular'), url('https://autodesk.github.io/standard-surface/style/fonts/RobotoMono/RobotoMono-Regular.woff2') format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD; /* Latin */
}

@font-face {
  font-family: 'Roboto Mono';
  font-style: normal;
  font-weight: 700;
  src: local('Roboto Mono Bold'), local('RobotoMono-Bold'), url('https://autodesk.github.io/standard-surface/style/fonts/RobotoMono/RobotoMono-Bold.woff2') format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD; /* Latin */
}

@font-face {
  font-family: 'PT Serif';
  font-style: italic;
  font-weight: 400;
  src: local('PT Serif Italic'), local('PTSerif-Italic'), url('https://autodesk.github.io/standard-surface/style/fonts/PTSerif/PTSerif-Italic.woff2') format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD; /* Latin */
}

@font-face {
  font-family: 'PT Serif';
  font-style: normal;
  font-weight: 400;
  src: local('PT Serif'), local('PTSerif-Regular'), url('https://autodesk.github.io/standard-surface/style/fonts/PTSerif/PTSerif-Regular.woff2') format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD; /* Latin */
}

@font-face {
  font-family: 'PT Serif';
  font-style: normal;
  font-weight: 700;
  src: local('PT Serif Bold'), local('PTSerif-Bold'), url('https://autodesk.github.io/standard-surface/style/fonts/PTSerif/PTSerif-Bold.woff2') format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD; /* Latin */
}

/******************************************************************************/
/* Document body
/******************************************************************************/

body
{
    max-width: 800px;
    font-family: 'PT Serif', serif;
    padding: 70px 10px 0px 10px;
    min-width: 260px;
    font-size: 16px;
    line-height: 21px;
    color: black;
}

@media print
{
    body
    {
        max-width: 100%;
        padding: 0 5%;
    }
}

/******************************************************************************/
/* Table of contents
/******************************************************************************/

/* For screens wide enough, put on the right side */
@media screen and (min-width: 1400px)
{
    .md .longTOC, .md .mediumTOC, .md .shortTOC
    {
        max-width: 300px;
        right: 0em;
        display: block;
        position: fixed;
        top: 0;
        bottom: 0;
        overflow-y: scroll;
        margin-top: 0;
        margin-bottom: 0;
        padding: 1em 1em 0 0;
        font-size: 85%;
        line-height: 120%;
        border: 0;
        opacity: 0.66;
        font-family: 'Artifakt Element', sans-serif;
    }

    .md .longTOC a, .md .mediumTOC a, .md .shortTOC a
    {
        font-family: 'Artifakt Element', sans-serif;
    }

    .md .longTOC:hover, .md .mediumTOC:hover, .md .shortTOC:hover
    {
        opacity: 1;
    }
}

/* For narrow screens, make inline */
@media screen and (max-width: 1399px)
{
    .md .longTOC, .md .mediumTOC, .md .shortTOC
    {
        display: block;
        margin: 20px 0 40px 3px;
        padding: 0;
        padding-top: 13px;
        float: initial;
        font-size: 98%;
        line-height: 120%;
        border: 0;
        font-family: 'Artifakt Element', sans-serif;
        border-top: 1px solid rgba(0,0,0,.1);
        border-bottom: 1px solid rgba(0,0,0,.1);
    }

    .md .longTOC a, .md .mediumTOC a, .md .shortTOC a
    {
        font-family: 'Artifakt Element', sans-serif;
    }
}

/* For print, hide */
@media print
{
    .md .longTOC, .md .mediumTOC, .md .shortTOC
    {
        display: none;
    }
}

.md div.title
{
    font-family: 'Artifakt Legend', sans-serif;
    font-weight: 700;
    border: 0;
}

contents, .md .tocHeader,
.md h1, .md h2, .md h3, .md h4, .md h5, .md h6,
.md .nonumberh1, .md .nonumberh2, .md .nonumberh3, .md .nonumberh4, .md .nonumberh5, .md .nonumberh6
{
    font-family: 'Artifakt Element', sans-serif;
    font-weight: 500;
    border: 0;
}

.md .tocHeader
{
    margin: 0;
    padding: 0;
    border: none;
    font-size: inherit;
}

.md .longTOC p, .md .mediumTOC p, .md .shortTOC p
{
    overflow: hidden;
    text-overflow: ellipsis;
}

.md .longTOC center, .md .mediumTOC center, .md .shortTOC center, .md .tocHeader
{
    text-align: left;
}

.md .longTOC b, .md .mediumTOC b, .md .shortTOC b
{
    font-weight: 500;
    font-size: 120%;
}

.md .longTOC a.level1, .md .mediumTOC a.level1, .md .shortTOC a.level1
{
    display: inline-block;
    color: rgba(0,0,0,.95);
    font-weight: 500;
    margin-top: 7px;
    margin-bottom: 4px;
}

.md .longTOC a.level2, .md .mediumTOC a.level2, .md .shortTOC a.level2
{
    color: rgba(0,0,0,.9);
    font-weight: 400;
    line-height: 130%;
}


/******************************************************************************/
/* Titles and headings
/******************************************************************************/

/* Title style */
.md div.title
{
    color: rgba(0,0,0,.7);
    margin: 0.4em 0 20px 0;
    padding: 0;
    font-size: 230%;
    font-weight: 700;
    text-align: center;
}

/* Subtitle style */
.md div.subtitle
{
    text-align: center;
    font-size: 95%;
}

/* Blue sections */
.md h1, .md .nonumberh1
{
    font-size: 150%;
    color: #029be5;
}

/* Grey sub-sections */
.md h2, .md .nonumberh2, .md h3, .md .nonumberh3
{
    font-size: 130%;
    color: rgba(0,0,0,.7);
}

.md h3, .md .nonumberh3
{
    font-size: 115%;
    margin-bottom: 0;
    color: rgba(0,0,0,.75);
}

/******************************************************************************/
/* Tables
/******************************************************************************/

.md table.table
{
    font-size: 90%;
    width: 100%;
    border: 1px solid rgb(230, 230, 230);
}

.md table.table td
{
    border: none;
    padding: 7px 7px 7px 7px;
}

/* Header row */
.md table.table th
{
    border: none;
    background-color: rgb(230, 230, 230);
    color: black;
    font-weight: 700;
    font-family: 'Artifakt Element', sans-serif;
    padding: 7px 7px 7px 7px;
}

/* Even table rows: 1, 3, ... */
.md table.table tr:nth-child(odd)
{
    background-color: rgb(247,247,247);
}

/* Odd table rows: 2, 4, ... */
.md table.table tr:nth-child(even)
{
    background-color: rgb(253, 253, 253);
}

.md table.table tr:hover
{
    background-color: #f9f5d7;
}


/******************************************************************************/
/* Links
/******************************************************************************/

.md a
{
    font-family: 'PT Serif';
}

.md a:link, .md a:visited
{
    color: #0085c7;
}

/* For print, make links black */
@media print
{
    .md a:link, .md a:visited
    {
        color: black;
    }
}

/******************************************************************************/
/* Misc
/******************************************************************************/

/* Code */
.md code
{
    padding: 0;
    border: none;
    font-family: 'Roboto Mono', monospace;
    font-size: 92%;
}
.md pre.listing
{
    background-color: transparent;
    font-size: 93%;
    background-color: rgb(250,250,250);
    border: 1px solid rgba(0,0,0,.05);
    padding: 6px 10px;
    text-align: left;
}

/* Bibliography */
.md .bib
{
    font-size: 90%;
    padding-left: 20px;
    text-indent: -20px;
}
.md .bib b
{
    font-weight: inherit;
    font-style: italic;
}

hr.pagebreak
{
    visibility: hidden;
}

.afterTitles
{
    height: 50px !important;
}

/* Center short image captions */
.md div.table
{
    margin: 0 0 30px 0;
}

.md div.tablecaption
{
    text-align: justify;
}

/* Center short image captions */
.md div.imagecaption
{
    display: inline-block;
    margin: 7px 0 0 0;
}

.md img.markdeep
{
    margin-top: 25px;
}

.md .subtitle img.markdeep
{
    margin-top: 7px;
}

.md .imagecaption b
{
    font-weight: 700;
    color: rgba(0,0,0,.85);
}

/* Hack to place a caption below a table of images */
.shifted-caption
{
    margin-top: -30px;
    text-align: center;
}
.shifted-caption .image
{
    float: initial !important;
    margin: 0 !important;
}
.shifted-caption img
{
    display: none;
}

.markdeepFooter
{
    opacity: 0.4;
}

.md code .long
{
    font-size: 88%;
}

/* For print, hide Markdeep footer */
@media print
{
    .markdeepFooter
    {
        display: none;
    }
}
</style>
<!-- <style class="fallback">body{visibility:hidden}</style><script>markdeepOptions={tocStyle:'long'};</script> -->
<!-- Markdeep: --><script src="https://casual-effects.com/markdeep/latest/markdeep.min.js?" charset="utf-8"></script>
<h1 align="center">F·W·K</h1>
<p align="center">Minimalist C framework for quick 3D game development.</p>

<!--## Gallery-->
<p align="center">
<img src="https://i.imgur.com/sInbRoA.gif"/><br/>
</p>

# F·W·K
This is a WIP page. Nothing to see here at the moment.

## audio
Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

## graphics
## filesystem
## scene
## input

```C linenumbers
int main(int argc, char **argv) {
    puts("hello");
}
```

## window

!!!
    I'm a note. Don't mind me, I'm just sitting here.

!!! note
    Another note.

!!! Tip
    Close the door on the way out.

!!! WARNING
    I'm a warning, perhaps. *Something might happen!*

!!! ERROR: Seriously
    Watch out, something **bad** could happen.

    This is still more error text.
# API 
## audio 

```C linenumbers 
API audio_t audio_clip( const char *pathfile );
API audio_t audio_stream( const char *pathfile );
API     int audio_play( audio_t s, int flags );
API float   audio_volume_clip(float gain);   // set     fx volume if gain is in [0..1] range. return current     fx volume in any case
API float   audio_volume_stream(float gain); // set    bgm volume if gain is in [0..1] range. return current    bgm volume in any case
API float   audio_volume_master(float gain); // set master volume if gain is in [0..1] range. return current master volume in any case
API int audio_queue( const void *samples, int num_samples, int flags );
```
## collide 

```C linenumbers 
API float   line_distance2_point(line l, vec3 p);
API vec3    line_closest_point(line l, vec3 p);
API float   ray_test_plane(ray r, vec4 p4);
API float   ray_test_triangle(ray r, triangle t);
API int     ray_test_sphere(float *t0, float *t1, ray r, sphere s);
API int     ray_test_aabb(float *t0, float *t1, ray r, aabb a);
API hit*    ray_hit_plane(ray r, plane p);
API hit*    ray_hit_triangle(ray r, triangle t);
API hit*    ray_hit_sphere(ray r, sphere s);
API hit*    ray_hit_aabb(ray r, aabb a);
API vec3    sphere_closest_point(sphere s, vec3 p);
API hit*    sphere_hit_aabb(sphere s, aabb a);
API hit*    sphere_hit_capsule(sphere s, capsule c);
API hit*    sphere_hit_sphere(sphere a, sphere b);
API int     sphere_test_aabb(sphere s, aabb a);
API int     sphere_test_capsule(sphere s, capsule c);
API int     sphere_test_poly(sphere s, poly p);
API int     sphere_test_sphere(sphere a, sphere b);
API vec3    aabb_closest_point(aabb a, vec3 p);
API float   aabb_distance2_point(aabb a, vec3 p);
API int     aabb_contains_point(aabb a, vec3 p);
API hit*    aabb_hit_aabb(aabb a, aabb b);
API hit*    aabb_hit_capsule(aabb a, capsule c);
API hit*    aabb_hit_sphere(aabb a, sphere s);
API int     aabb_test_aabb(aabb a, aabb b);
API int     aabb_test_capsule(aabb a, capsule c);
API int     aabb_test_poly(aabb a, poly p);
API int     aabb_test_sphere(aabb a, sphere s);
API float   capsule_distance2_point(capsule c, vec3 p);
API vec3    capsule_closest_point(capsule c, vec3 p);
API hit*    capsule_hit_aabb(capsule c, aabb a);
API hit*    capsule_hit_capsule(capsule a, capsule b);
API hit*    capsule_hit_sphere(capsule c, sphere s);
API int     capsule_test_aabb(capsule c, aabb a);
API int     capsule_test_capsule(capsule a, capsule b);
API int     capsule_test_poly(capsule c, poly p);
API int     capsule_test_sphere(capsule c, sphere s);
API int     poly_test_sphere(poly p, sphere s);
API int     poly_test_aabb(poly p, aabb a);
API int     poly_test_capsule(poly p, capsule c);
API int     poly_test_poly(poly a, poly b);
API int     poly_test_sphere_transform(poly p, vec3 pos3, mat33 rot33, sphere s);
API int     poly_test_aabb_transform(poly p, vec3 apos3, mat33 arot33, aabb a);
API int     poly_test_capsule_transform(poly p, vec3 pos3, mat33 rot33, capsule c);
API int     poly_test_poly_transform(poly a, vec3 apos3, mat33 arot33, poly b, vec3 bpos3, mat33 brot33);
API int     poly_hit_sphere(struct gjk_result *res, poly p, sphere s);
API int     poly_hit_aabb(struct gjk_result *res, poly p, aabb a);
API int     poly_hit_capsule(struct gjk_result *res, poly p, capsule c);
API int     poly_hit_poly(struct gjk_result *res, poly a, poly b);
API int     poly_hit_sphere_transform(struct gjk_result *res, poly p, vec3 pos3, mat33 rot33, sphere s);
API int     poly_hit_aabb_transform(struct gjk_result *res, poly p, vec3 pos3, mat33 rot33, aabb a);
API int     poly_hit_capsule_transform(struct gjk_result *res, poly p, vec3 pos3, mat33 rot33, capsule c);
API int     poly_hit_poly_transform(struct gjk_result *res, poly a, vec3 at3, mat33 ar33, poly b, vec3 bt3, mat33 br33);
API vec4    plane4(vec3 p, vec3 n);
API frustum frustum_build(mat44 projview);
API int     frustum_test_sphere(frustum f, sphere s);
API int     frustum_test_aabb(frustum f, aabb a);
API poly    poly_alloc(int cnt);
API void    poly_free(poly *p);
API poly    pyramid(vec3 from, vec3 to, float size); // poly_free() required
API poly    diamond(vec3 from, vec3 to, float size); // poly_free() required
```
## cooker 

```C linenumbers 
API int  cooker_progress(); // [0..100]
API bool cooker( const char *masks, cooker_callback_t cb, int flags );
```
## data 

```C linenumbers 
API bool    data_push(const char *source);
API int         data_count(const char *keypath);
API bool    data_pop();
API data_t data_get(bool is_string, const char *keypath); // @todo, array(data_t) data_array();
```
## dll 

```C linenumbers 
API void* dll(const char *filename, const char *symbol);
```
## ds 

```C linenumbers 
API void  (set_init)(set *m);
API void  (set_free)(set *m);
API void  (set_insert)(set *m, set_item *p, void *key, uint64_t keyhash, void *super);
API void  (set_erase)(set *m, void *key, uint64_t keyhash);
API void* (set_find)(const set *m, void *key, uint64_t keyhash);
API int   (set_count)(const set *m);
API void  (set_gc)(set *m); // only if using SET_DONT_ERASE
API void  (map_init)(map *m);
API void  (map_free)(map *m);
API void  (map_insert)(map *m, pair *p, void *key, void *value, uint64_t keyhash, void *super);
API void  (map_erase)(map *m, void *key, uint64_t keyhash);
API void* (map_find)(map *m, void *key, uint64_t keyhash);
API int   (map_count)(map *m);
API void  (map_gc)(map *m); // only if using MAP_DONT_ERASE
```
## editor 

```C linenumbers 
API void editor();
API bool editor_active();
API int  gizmo(vec3 *pos, vec3 *rot, vec3 *sca);
API bool gizmo_active();
```
## file 

```C linenumbers 
API const char** file_list(const char *masks); // **.png;*.c
API char *       file_read(const char *filename);
API char *       file_load(const char *filename, int *len);
API uint64_t     file_size(const char *pathfile);
API bool         file_directory(const char *pathfile);
API char *       file_path(const char *pathfile); // c:/prj/dir/file.ext -> c:/prj/dir/
API char *       file_name(const char *pathfile); // c:/prj/dir/file.ext -> file.ext
API char *       file_ext(const char *pathfile); // c:/prj/dir/file.ext -> .ext
API char *       file_id(const char *pathfile); // c:/prj/dir/file.ext -> file/dir/prj (name then alphabetical)
API char *       file_normalize(const char *pathfile); // c:/prj/dir/file.ext -> c/prj/dir/file_ext
//API char *     file_normalize_with_folder(const char *pathfile); // c:/prj/dir/file.ext -> dir/file_ext
API uint64_t     file_stamp(const char *pathfile); // 1616153596 (seconds since unix epoch)
API uint64_t     file_stamp_human(const char *pathfile); // 20210319113316 (datetime in base10)
API bool         file_copy(const char *src, const char *dst);
API FILE*        file_temp();
API char*        file_tempname();
API bool         vfs_mount(const char *mount_point);
API const char** vfs_list(const char *masks); // **.png;*.c
API char *       vfs_read(const char *pathfile);
API char *       vfs_load(const char *pathfile, int *size);
API int          vfs_size(const char *pathfile);
API const char * vfs_resolve(const char *fuzzyname); // guess best match. @todo: fuzzy path
API const char * vfs_find(const char *pathfile); // returns filename to extracted temporary file, so it can be read by foreign/3rd party libs
API FILE*        vfs_handle(const char *pathfile); // same as above, but returns file handle instead. preferred way, will clean descriptors at exit
API void *       cache_insert(const char *key, void *value, int size);
API void *       cache_lookup(const char *key, int *size);
```
## input 

```C linenumbers 
API int         input_use( int controller_id ); // [0..3]
API float       input( int vk );
API vec2        input2( int vk );
API float       input_diff( int vk );
API vec2        input_diff2( int vk );
API float       input_frame( int vk, int frame );
API vec2        input_frame2( int vk, int frame );
API const char* input_frames( int vk, int frame );
API int         input_up( int vk ); // ON -> OFF (release)
API int         input_down( int vk ); // OFF -> ON (trigger)
API int         input_held( int vk ); // ON -> ON (pressed)
API int         input_idle( int vk ); // OFF -> OFF
API int         input_click( int vk, int ms ); // OFF -> ON -> OFF
API int         input_click2( int vk, int ms ); // OFF -> ON -> OFF -> ON -> OFF
API int         input_repeat( int vk, int ms ); // [...] ON -> ON -> ON
API int         input_chord2( int vk1, int vk2 ); // all vk1 && vk2 are ON
API int         input_chord3( int vk1, int vk2, int vk3 ); // all vk1 && vk2 && vk3 are ON
API int         input_chord4( int vk1, int vk2, int vk3, int vk4 ); // all vk1 && vk2 && vk3 && vk4 are ON
API float       input_filter_positive( float v ); // [-1..1] -> [0..1]
API vec2        input_filter_positive2( vec2 v ); // [-1..1] -> [0..1]
API vec2        input_filter_deadzone( vec2 v, float deadzone );
API vec2        input_filter_deadzone_4way( vec2 v, float deadzone );
API void        input_demo();
API void        input_send( int vk ); // @todo
API void*       input_save_state( int id, int *size); // @todo
API bool        input_load_state( int id, void *ptr, int size); // @todo
```
## math 




```C linenumbers 
API void     randset(uint64_t state);
API uint64_t rand64(void);
API double   randf(void); // [0, 1) interval
API int      randi(int mini, int maxi); // [mini, maxi) interval
API float simplex1( float x );
API float simplex2( vec2 xy );
API float simplex3( vec3 xyz );
API float simplex4( vec4 xyzw );
API float ease_linear(float t);
API float ease_out_sine(float t);
API float ease_out_quad(float t);
API float ease_out_cubic(float t);
API float ease_out_quart(float t);
API float ease_out_quint(float t);
API float ease_out_expo(float t);
API float ease_out_circ(float t);
API float ease_out_back(float t);
API float ease_out_elastic(float t);
API float ease_out_bounce(float t);
API float ease_in_sine(float t);
API float ease_in_quad(float t);
API float ease_in_cubic(float t);
API float ease_in_quart(float t);
API float ease_in_quint(float t);
API float ease_in_expo(float t);
API float ease_in_circ(float t);
API float ease_in_back(float t);
API float ease_in_elastic(float t);
API float ease_in_bounce(float t);
API float ease_inout_sine(float t);
API float ease_inout_quad(float t);
API float ease_inout_cubic(float t);
API float ease_inout_quart(float t);
API float ease_inout_quint(float t);
API float ease_inout_expo(float t);
API float ease_inout_circ(float t);
API float ease_inout_back(float t);
API float ease_inout_elastic(float t);
API float ease_inout_bounce(float t);
API float ease_perlin_inout(float t);
API float ease_ping_pong(float t, float(*fn1)(float), float(*fn2)(float));
API float ease_pong_ping(float t, float(*fn1)(float), float(*fn2)(float));
API float deg      (float radians)      ;
API float rad      (float degrees)      ;
API int   mini     (int    a, int    b);
API int   maxi     (int    a, int    b);
API int   absi     (int    a          );
API float minf     (float  a, float  b);
API float maxf     (float  a, float  b);
API float absf     (float  a          );
API float pmodf    (float  a, float  b);
API float signf    (float  a)           ;
API float clampf(float v,float a,float b);
API float mixf(float a,float b,float t);
API vec2  ptr2     (const float *a    );
API vec2  neg2     (vec2   a          );
API vec2  add2     (vec2   a, vec2   b);
API vec2  sub2     (vec2   a, vec2   b);
API vec2  mul2     (vec2   a, vec2   b);
API vec2  inc2     (vec2   a, float  b);
API vec2  dec2     (vec2   a, float  b);
API vec2  scale2   (vec2   a, float  b);
API vec2  div2     (vec2   a, float  b);
API vec2  pmod2    (vec2   a, float  b);
API vec2  min2     (vec2   a, vec2   b);
API vec2  max2     (vec2   a, vec2   b);
API vec2  abs2     (vec2   a          );
API vec2  floor2   (vec2   a          );
API vec2  fract2   (vec2   a          );
API vec2  ceil2    (vec2   a          );
API float dot2     (vec2   a, vec2   b);
API vec2  refl2    (vec2   a, vec2   b);
API float cross2   (vec2   a, vec2   b);
API float len2sq   (vec2   a          );
API float len2     (vec2   a          );
API vec2  norm2    (vec2   a          );
API int   finite2  (vec2   a          );
API vec2  mix2  (vec2 a,vec2 b,float t);
API vec2  clamp2(vec2 v,float a,float b);
API vec3  ptr3     (const float *a    );
API vec3  vec23    (vec2   a, float z );
API vec3  neg3     (vec3   a          );
API vec3  add3     (vec3   a, vec3   b);
API vec3  sub3     (vec3   a, vec3   b);
API vec3  mul3     (vec3   a, vec3   b);
API vec3  inc3     (vec3   a, float  b);
API vec3  dec3     (vec3   a, float  b);
API vec3  scale3   (vec3   a, float  b);
API vec3  div3     (vec3   a, float  b);
API vec3  pmod3    (vec3   a, float  b);
API vec3  min3     (vec3   a, vec3   b);
API vec3  max3     (vec3   a, vec3   b);
API vec3  abs3     (vec3   a          );
API vec3  floor3   (vec3   a          );
API vec3  fract3   (vec3   a          );
API vec3  ceil3    (vec3   a          );
API vec3  cross3   (vec3   a, vec3   b);
API float dot3     (vec3   a, vec3   b);
API vec3  refl3    (vec3   a, vec3   b);
API float len3sq   (vec3   a          );
API float len3     (vec3   a          );
API vec3  norm3    (vec3   a          );
API vec3  norm3sq  (vec3   a          );
API int   finite3  (vec3   a          );
API vec3  mix3  (vec3 a,vec3 b,float t);
API vec3  clamp3(vec3 v,float a,float b);
API void  ortho3   (vec3 *left, vec3 *up, vec3 v);
API vec4  ptr4     (const float *a    );
API vec4  vec34    (vec3   a, float w );
API vec4  neg4     (vec4   a          );
API vec4  add4     (vec4   a, vec4   b);
API vec4  sub4     (vec4   a, vec4   b);
API vec4  mul4     (vec4   a, vec4   b);
API vec4  inc4     (vec4   a, float  b);
API vec4  dec4     (vec4   a, float  b);
API vec4  scale4   (vec4   a, float  b);
API vec4  div4     (vec4   a, float  b);
API vec4  pmod4    (vec4   a, float  b);
API vec4  min4     (vec4   a, vec4   b);
API vec4  max4     (vec4   a, vec4   b);
API vec4  abs4     (vec4   a          );
API vec4  floor4   (vec4   a          );
API vec4  fract4   (vec4   a          );
API vec4  ceil4    (vec4   a          );
API float dot4     (vec4   a, vec4   b);
API vec4  refl4    (vec4   a, vec4   b);
API float len4sq   (vec4   a          );
API float len4     (vec4   a          );
API vec4  norm4    (vec4   a          );
API vec4  norm4sq  (vec4   a          );
API int   finite4  (vec4   a          );
API vec4  mix4  (vec4 a,vec4 b,float t);
API vec4  clamp4(vec4 v,float a,float b);
API quat  idq      (                  );
API quat  ptrq     (const float *a    );
API quat  vec3q    (vec3   a, float w );
API quat  vec4q    (vec4   a          );
API quat  negq     (quat   a          );
API quat  conjq    (quat   a          );
API quat  addq     (quat   a, quat   b);
API quat  subq     (quat   a, quat   b);
API quat  mulq     (quat   p, quat   q);
API quat  scaleq   (quat   a, float  s);
API quat  normq    (quat   a          );
API float dotq     (quat   a, quat   b);
API quat  mixq(quat a, quat b, float t);
API quat slerpq(quat a, quat b, float s);
API quat  rotationq(float deg,float x,float y,float z);
API quat  mat44q   (mat44 M);
API vec3 rotate3q_2(vec3 v, quat q);
API vec3 rotate3q(vec3 v, quat r);
API vec3  euler    (quat q);
API quat  eulerq   (vec3 pyr_degrees);
API void scaling33(mat33 m, float x, float y, float z);
API void scale33(mat33 m, float x, float y, float z);
API void id33(mat33 m);
API void extract33(mat33 m, const mat44 m4);
API void copy33(mat33 m, const mat33 a);//
API vec3 mulv33(mat33 m, vec3 v);
API void multiply33x2(mat33 m, const mat33 a, const mat33 b);
API void rotation33(mat33 m, float degrees, float x,float y,float z);
API void rotationq33(mat33 m, quat q);
API void rotate33(mat33 r, float degrees, float x,float y,float z);
API void compose33(mat33 m, quat r, vec3 s);
API void id34(mat34 m);
API void copy34(mat34 m, const mat34 a);
API void scale34(mat34 m, float s);
API void add34(mat34 m, mat34 n);
API void muladd34(mat34 m, mat34 n, float s);
API void add34x2(mat34 m, mat34 n, mat34 o);
API void lerp34(mat34 m, mat34 n, mat34 o, float alpha); // mix34?
API void multiply34x2(mat34 m, const mat34 m0, const mat34 m1);
API void multiply34(mat34 m, const mat34 a);
API void multiply34x3(mat34 m, const mat34 a, const mat34 b, const mat34 c);
API void compose34(mat34 m, vec3 t, quat q, vec3 s);
API void invert34(mat34 m, const mat34 o);
API void scaling44(mat44 m, float x, float y, float z);
API void id44(mat44 m);
API void identity44(mat44 m);
API void copy44(mat44 m, const mat44 a);
API void multiply44x2(mat44 m, const mat44 a, const mat44 b);
API void multiply44x3(mat44 m, const mat44 a, const mat44 b, const mat44 c);
API void multiply44(mat44 m, const mat44 a);
API void ortho44(mat44 m, float l, float r, float b, float t, float n, float f);
API void frustum44(mat44 m, float l, float r, float b, float t, float n, float f);
API void perspective44(mat44 m, float fovy_degrees, float aspect, float nearp, float farp);
API void lookat44(mat44 m, vec3 eye, vec3 center, vec3 up);
API void translation44(mat44 m, float x, float y, float z);
API void translate44(mat44 m, float x, float y, float z);
API void relocate44(mat44 m, float x, float y, float z);
API void rotationq44(mat44 m, quat q);
API void rotation44(mat44 m, float degrees, float x, float y, float z);
API void rotate44(mat44 m, float degrees, float x, float y, float z);
API void scaling44(mat44 m, float x, float y, float z);
API void scale44(mat44 m, float x, float y, float z);
API void transpose44(mat44 m, const mat44 a);
API float det44(const mat44 M);
API bool invert44(mat44 T, const mat44 M);
API vec4 transform444(const mat44, const vec4);
API bool unproject44(vec3 *out, vec3 xyd, vec4 viewport, mat44 mvp);
API vec3 transform_axis(const coord_system, const coord_axis);
API void rebase44(mat44 m, const coord_system src_basis, const coord_system dst_basis);
API void compose44(mat44 m, vec3 t, quat q, vec3 s);
API vec3 transform33(mat33 m, vec3 p);
API vec4 transform444(const mat44 m, const vec4 p);
API vec3 transform344(const mat44 m, const vec3 p);
API vec3 transformq(const quat q, const vec3 v);
API vec3 transform_axis(const coord_system basis, const coord_axis to);
API vec3 transform_vector  (const mat44 m, const vec3 vector)   ;
API vec3 transform_point   (const mat44 m, const vec3 p)    ; // return (m * vec4{point,1).xyz()/r.w;
API vec3 transform_tangent (const mat44 m, const vec3 tangent)  ;//{ return norm3(transform_vector(m, tangent)); }
API vec3 transform_normal  (const mat44 m, const vec3 normal)   ;
API quat transform_quat     (const mat44 m, const quat q)      ;
API float* transform_matrix(mat44 out, const mat44 m, const mat44 matrix);
API vec3 transform_scaling (const mat44 m, const vec3 scaling);
API void print2( vec2 v );
API void print3( vec3 v );
API void print4( vec4 v );
API void printq( quat q );
API void print33( float *m );
API void print34( float *m );
API void print44( float *m );
```
## memory 

```C linenumbers 
API void*  xrealloc(void* p, size_t sz);
API size_t xsize(void* p);
API void*  stack(int bytes);
API void*  watch( void *ptr, int sz );
API void*  forget( void *ptr );
```
## network 

```C linenumbers 
API int download( FILE *out, const char *url );
API int portname( const char *service_name, unsigned retries );
API int   udp_bind(const char *address, const char *port);
API int   udp_open(const char *address, const char *port);
API int   udp_send(int, const void *buf, int len ); // <0 error, >0 bytes sent ok
API int   udp_sendto(int, const char *ip, const char *port, const void *buf, int len ); // <0 error, >0 bytes sent ok
API int   udp_recv(int, void *buf, int len ); // <0 error, 0 orderly shutdown, >0 received bytes
API int   udp_peek(int); // <0 error, 0 timeout, >0 data
API int   tcp_open(const char *address, const char *port);
API int   tcp_bind(const char *interface_, const char *port, int queue);
API int   tcp_peek(int, int(*callback)(int));
API int   tcp_send(int, const void* buf, int len);
API int   tcp_recv(int, void* buf, int len);
API char* tcp_host(int); // info
API char* tcp_port(int); // info
API int   tcp_close(int);
API int   tcp_debug(int); // toggle traffic monitoring on/off for given socket
//API int   tcp_printf(int, const char *fmt, ...); // printf message in remote end
//API int   tcp_crypt(int,uint64_t);               // set shared secret
```
## profile 

```C linenumbers 
```
## render 

```C linenumbers 
API uint32_t rgba( uint8_t r, uint8_t g, uint8_t b, uint8_t a );
API uint32_t bgra( uint8_t r, uint8_t g, uint8_t b, uint8_t a );
API float    alpha( uint32_t rgba );
API image_t image(const char *pathfile, int flags);
API image_t image_from_mem(const char *ptr, int len, int flags);
API void    image_destroy(image_t *img);
API texture_t texture(const char* filename, int flags);
API texture_t texture_from_mem(const char* ptr, int len, int flags);
API texture_t texture_create(unsigned w, unsigned h, unsigned n, void *pixels, int flags);
API texture_t texture_checker();
API void      texture_destroy(texture_t *t);
API unsigned  texture_update(texture_t *t, unsigned w, unsigned h, unsigned n, void *pixels, int flags);
API void  fullscreen_rgb_quad( texture_t texture_rgb, float gamma );
API void  fullscreen_ycbcr_quad( texture_t texture_YCbCr[3], float gamma );
API void tile( texture_t texture, vec3 position, uint32_t color /*~0u*/, float rotation /*0*/ );
API void sprite( texture_t texture,
API void sprite_update();
API cubemap_t  cubemap( const image_t image, int flags ); // 1 equirectangular panorama
API cubemap_t  cubemap6( const image_t images[6], int flags ); // 6 cubemap faces
API void       cubemap_destroy(cubemap_t *c);
API cubemap_t* cubemap_get_active();
API unsigned fbo( unsigned texture_color, unsigned texture_depth, int wr_flags );
API void     fbo_bind(unsigned id);
API void     fbo_unbind();
API void     fbo_destroy(unsigned id);
API shadowmap_t shadowmap(int texture_width); // = 1024
API void shadowmap_destroy(shadowmap_t *s);
API void shadowmap_set_shadowmatrix(shadowmap_t *s, vec3 aLightPos, vec3 aLightAt, vec3 aLightUp, const mat44 projection);
API void shadowmap_begin(shadowmap_t *s);
API void shadowmap_end(shadowmap_t *s);
API void shadowmatrix_proj(mat44 shm_proj, float aLightFov, float znear, float zfar);
API void shadowmatrix_ortho(mat44 shm_proj, float left, float right, float bottom, float top, float znear, float zfar);
API unsigned shader(const char *vs, const char *fs, const char *attribs, const char *fragcolor);
API unsigned shader_bind(unsigned program);
API     void shader_int(const char *uniform, int i);
API     void shader_float(const char *uniform, float f);
API     void shader_vec2(const char *uniform, vec2 v);
API     void shader_vec3(const char *uniform, vec3 v);
API     void shader_vec4(const char *uniform, vec4 v);
API     void shader_mat44(const char *uniform, mat44 m);
API     void shader_texture(const char *sampler, unsigned texture, unsigned unit);
API unsigned shader_get_active();
API void     shader_destroy(unsigned shader);
API mesh_t mesh_create(const char *format, int vertex_stride,int vertex_count,const void *interleaved_vertex_data, int index_count,const void *index_data, int flags);
API   void mesh_upgrade(mesh_t *m, const char *format, int vertex_stride,int vertex_count,const void *interleaved_vertex_data, int index_count,const void *index_data, int flags);
API   void mesh_push_state(mesh_t *m, unsigned program, unsigned texture_id, float model[16], float view[16], float proj[16], unsigned billboard);
API   void mesh_pop_state(mesh_t *m);
API   void mesh_render(mesh_t *m);
API   void mesh_destroy(mesh_t *m);
API   aabb mesh_bounds(mesh_t *m);
API model_t  model(const char *filename, int flags);
API model_t  model_from_mem(const void *mem, int sz, int flags);
API float    model_animate(model_t, float curframe);
API float    model_animate_clip(model_t, float curframe, int minframe, int maxframe, bool loop);
API aabb     model_aabb(model_t, mat44 transform);
API void     model_render2(model_t, mat44 proj, mat44 view, mat44 model, int shader);
API void     model_render(model_t, mat44 proj, mat44 view, mat44 model);
API void     model_destroy(model_t);
API skybox_t skybox(const char *panorama_or_cubemap_folder, int flags);
API int      skybox_push_state(skybox_t *sky, mat44 proj, mat44 view);
API int      skybox_pop_state(skybox_t *sky);
API void     skybox_destroy(skybox_t *sky);
API void     viewport_color(vec3 color);
API void     viewport_clear(bool color, bool depth);
API void     viewport_clip(vec2 from, vec2 to);
API void     fx_load(const char *file);
API void     fx_begin();
API void     fx_end();
API void     fx_enable(int pass, int enabled);
API int      fx_enabled(int pass);
API void     fx_enable_all(int enabled);
API char *   fx_name(int pass);
API void*    screenshot(unsigned components); // 3 RGB, 4 RGBA, -3 BGR, -4 BGRA
```
## renderdd 

```C linenumbers 
API void ddraw_color(unsigned rgb);
API void ddraw_ontop(int enabled);
API void ddraw_aabb(vec3 minbb, vec3 maxbb);
API void ddraw_aabb_corners(vec3 minbb, vec3 maxbb);
API void ddraw_arrow(vec3 begin, vec3 end);
API void ddraw_axis(float units);
API void ddraw_boid(vec3 pos, vec3 dir);
API void ddraw_bone(vec3 center, vec3 end); // @todo: use me
API void ddraw_bounds(const vec3 points[8]);
API void ddraw_box(vec3 c, vec3 extents);
API void ddraw_capsule(vec3 from, vec3 to, float radius);
API void ddraw_circle(vec3 pos, vec3 n, float radius);
API void ddraw_cone(vec3 center, vec3 top, float radius);
API void ddraw_cube(vec3 center, float radius);
API void ddraw_diamond(vec3 from, vec3 to, float size);
API void ddraw_frustum(float projview[16]);
API void ddraw_ground(float scale);
API void ddraw_grid(float scale);
API void ddraw_hexagon(vec3 pos, float radius);
API void ddraw_line(vec3 from, vec3 to);
API void ddraw_line_dashed(vec3 from, vec3 to);
API void ddraw_line_thin(vec3 from, vec3 to);
API void ddraw_normal(vec3 pos, vec3 n);
API void ddraw_pentagon(vec3 pos, float radius);
API void ddraw_plane(vec3 p, vec3 n, float scale);
API void ddraw_point(vec3 from);
API void ddraw_position(vec3 pos, float radius);
API void ddraw_position_dir(vec3 pos, vec3 dir, float radius);
API void ddraw_pyramid(vec3 center, float height, int segments);
API void ddraw_sphere(vec3 pos, float radius);
API void ddraw_square(vec3 pos, float radius);
API void ddraw_text(vec3 pos, float scale, const char *text);
API void ddraw_text2d(vec2 pos, float scale, const char *text);
API void ddraw_triangle(vec3 p1, vec3 p2, vec3 p3);
API void ddraw_demo();
API void ddraw_flush();
```
## scene 

```C linenumbers 
API camera_t camera();
API void camera_move(camera_t *cam, float x, float y, float z);
API void camera_fps(camera_t *cam, float yaw, float pitch);
API void camera_lookat(camera_t *cam, vec3 target);
API camera_t *camera_get_active();
API object_t object();
API void object_rotate(object_t *obj, vec3 euler);
API void object_pivot(object_t *obj, vec3 euler);
API void object_teleport(object_t *obj, vec3 pos);
API void object_move(object_t *obj, vec3 inc);
API vec3 object_position(object_t *obj);
API void object_scale(object_t *obj, vec3 sca);
API void object_model(object_t *obj, model_t model);
API void object_diffuse(object_t *obj, texture_t tex);
API void object_billboard(object_t *obj, unsigned mode);
API scene_t*  scene_push();
API void      scene_pop();
API scene_t*  scene_get_active();
API int       scene_merge(const char *source);
API void      scene_render(int flags);
API object_t* scene_spawn();
API unsigned  scene_count();
API object_t* scene_index(unsigned index);
```
## script 

```C linenumbers 
API void script_init();
API void script_run(const char *script);
API void script_runfile(const char *pathfile);
API void script_bind_class(const char *objname, int num_methods, const char **c_names, void **c_functions);
API void script_bind_function(const char *c_name, void *c_function);
API void script_call(const char *lua_function);
```
## string 

```C linenumbers 
API char*   stringf(const char *fmt, ...);
API char*   stringf_cat(char *x, const char *buf);
API int          strmatch(const char *s, const char *wildcard);
API int          strcmp_qsort(const void *a, const void *b);
API int          strcmpi_qsort(const void *a, const void *b);
API bool         strbegi(const char *src, const char *sub);  // returns true if both strings match at beginning. case insensitive
API bool         strendi(const char *src, const char *sub);  // returns true if both strings match at end. case insensitive
API const char * strstri(const char *src, const char *sub);  // returns find first substring in string. case insensitive.
API char *       strrepl(char **copy, const char *target, const char *replace); // replace any 'target' as 'repl' in 'copy'. returns 'copy'
API char *       strswap(char *copy, const char *target, const char *replace);  // replaced only if repl is shorter than target. no allocations.
API char *       strcut(char *copy, const char *target);                        // remove any 'target' in 'copy'. returns 'copy'
API char *       str16to8(const wchar_t *str); // convert from wchar16(win) to utf8/ascii
API const char * strlerp(unsigned numpairs, const char **pairs, const char *str); // using key-value pairs, null-terminated
API size_t       strlcat(char *dst, const char *src, size_t dstcap); // concat 2 strings safely. always NUL terminates. may truncate.
API size_t       strlcpy(char *dst, const char *src, size_t dstcap); // copy 2 strings safely. always NUL terminates. truncates if retval>=dstcap
API array(char*) strsplit(const char *string, const char *delimiters);
API char*        strjoin(array(char*) list, const char *separator);
```
## system 

```C linenumbers 
API int         argc();
API char*       argv(int);
API const char* option(const char *commalist, const char *defaults);
API int         optioni(const char *commalist, int defaults);
API float       optionf(const char *commalist, float defaults);
API char*       os_exec_output();
API int         os_exec(const char *command);
API void        tty_color(unsigned color);
API void        tty_reset();
API int         cpu_cores(void);
API const char* app_name();
API const char* app_path();
API const char* app_cache();
API const char* app_temp();
API void        app_reload();
API double      time_ss();
API double      time_ms();
API uint64_t    time_us();
API uint64_t    date_human(); // YYYYMMDDhhmmss
API double      sleep_ss(double ss);
API double      sleep_ms(double ms);
API uint64_t    sleep_us(uint64_t us);
API char*       callstack( int traces ); // write callstack into a temporary string. do not delete it.
API int         callstackf( FILE *fp, int traces ); // write callstack to file. <0 traces to invert order.
API void        die(const char *message);
API void        alert(const char *message);
API void        hexdump( const void *ptr, unsigned len );
API void        hexdumpf( FILE *fp, const void *ptr, unsigned len, int width );
API void        breakpoint(const char *reason);
API bool        has_debugger();
API uint16_t    lil16(uint16_t n); // swap16 as lil
API uint32_t    lil32(uint32_t n); // swap32 as lil
API float       lil32f(float n);   // swap32 as lil
API uint64_t    lil64(uint64_t n); // swap64 as lil
API double      lil64f(double n);  // swap64 as lil
API uint16_t    big16(uint16_t n); // swap16 as big
API uint32_t    big32(uint32_t n); // swap32 as big
API float       big32f(float n);   // swap32 as big
API uint64_t    big64(uint64_t n); // swap64 as big
API double      big64f(double n);  // swap64 as big
API uint16_t*   lil16p(void *n, int sz);
API uint32_t*   lil32p(void *n, int sz);
API float*      lil32pf(void *n, int sz);
API uint64_t*   lil64p(void *n, int sz);
API double*     lil64pf(void *n, int sz);
API uint16_t*   big16p(void *n, int sz);
API uint32_t*   big32p(void *n, int sz);
API float*      big32pf(void *n, int sz);
API uint64_t*   big64p(void *n, int sz);
API double*     big64pf(void *n, int sz);
API int (PRINTF)(const char *text, const char *stack, const char *file, int line, const char *function);
API int (PANIC)(const char *error, const char *file, int line);
```
## ui 

```C linenumbers 
API int  ui_begin(const char *title, int flags);
API int    ui_int(const char *label, int *value);
API int    ui_bool(const char *label, bool *value);
API int    ui_short(const char *label, short *value);
API int    ui_float(const char *label, float *value);
API int    ui_float2(const char *label, float value[2]);
API int    ui_float3(const char *label, float value[3]);
API int    ui_string(const char *label, char *buffer, int buflen);
API int    ui_color3(const char *label, float *color3);
API int    ui_color4(const char *label, float *color4);
API int    ui_button(const char *label);
API int    ui_toggle(const char *label, bool *value);
API int    ui_dialog(const char *title, const char *text, int choices, bool *show); // @fixme: return
API int    ui_list(const char *label, const char **items, int num_items, int *selector);
API int    ui_separator();
API int    ui_label(const char *label);
API int    ui_label2(const char *label, const char *caption);
API int    ui_slider(const char *label, float *value);
API int    ui_slider2(const char *label, float *value, const char *caption);
API int    ui_const_bool(const char *label, const double value);
API int    ui_const_float(const char *label, const double value);
API int    ui_const_string(const char *label, const char *value);
API void ui_end();
API int  ui_menu(const char *items); // semicolon- or comma-separated items
API int  ui_item();
API int  ui_hover(); // ui_is_hover()?
API int  ui_active(); // ui_is_active()?
API void ui_demo();
```
## video 

```C linenumbers 
API video_t*   video( const char *filename, int flags );
API texture_t*  video_decode( video_t *v ); // decodes next frame, returns associated texture(s)
API int         video_has_finished(video_t *v);
API double      video_duration(video_t *v);
API int         video_seek(video_t *v, double seek_to);
API double      video_position(video_t *v);
API void       video_destroy( video_t *v );
```
## window 

```C linenumbers 
API void   window_create(float zoom, int flags);
API void   window_title(const char *title);
API void   window_icon(const char *file_icon);
API void   window_flush();
API int    window_swap();
API void*  window_handle();
API int    window_width();
API int    window_height();
API double window_aspect();
API double window_time();
API double window_delta();
API double window_fps();
API bool   window_hook(void (*func)(), void* userdata);
API void   window_unhook(void (*func)());
API void   window_focus(); // window attribute api using haz catz language for now
API int    window_has_focus();
API void   window_fullscreen(int enabled);
API int    window_has_fullscreen();
API void   window_cursor(int visible);
API int    window_has_cursor();
API void   window_pause();
API int    window_has_pause();
API void   window_visible(int visible);
API int    window_has_visible();
API void   window_videorec(const char* filename_mpg);
API int    window_has_videorec();
API void   window_screenshot(const char* filename_png);
```
